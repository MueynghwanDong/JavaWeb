1. Spring Starter Project (String Boot)
- 별도로 설정이 필요 없음
- WAS없이 실행이 가능
- 로딩 시간이 짧아서 테스트 하기에 편하다
- 기존 설정과 다른 방식으로 사용
- JSP 설정 등은 별도로 해야함.
2. Spring Project
- 다양한 자료가 존재하며 기존 프로젝트를 이해하는데 도움이 됨.
- 모든 버전의 스프링에서 사용 가능
- 초반 테스트 환경 구성 등이 어렵고 WAS와 연동하는 경우 결과 확인에 많은 리소스를 소모한다.

프레임워크를 통해 프로그램의 기본 흐름이나 구조를 정하고 팀원이 구조에 자신의 코드를 추가하는 방식으로 개발
- 복잡성을 해결하기 위해 나온 경량화 프레임워크
- 한 분야야ㅔ 집중하지 않고 전체를 설계하는 용도로 사용될 수 있었음 
- 다른 프레임워크들과 통합을 지원, 기본 뼈대를 흔들지 않고 여러 종류의 프레임워크를 혼용해 사용
- 개발 생산성과 개발 도구의 지원
주요 특징 
- POJO 기반의 구성 
  - 객체 간의 관계를 구성할 수 있는 특징을 가진다.
- 의존성 주입을 통한 객체 간의 관계 구성
  - 특정 객체에 필요한 객체를 외부에서 결정해 연결 시키는 것을 의미
  - 생성자를 통한 주입 / set 메소드를 이용한 주입 
- AOP 의 지원 
- 트랜잭션의 지원 

Presentation Layer (뷰를 구성하는 부분과 Controller 부분으로 분리되어 작성) 
- ui를 담당하는 구성 요소들이 있다.
Business Layer 
- 서비스 계층, 고객의 요구사항을 반영 하는 계층, 사용자 환경이 아닌 기능적 요구사항을 구현하는 곳
- 어떤 형태의 데이터가 필요하고 반환될 것인지 결정
Data Access Layer (Persistence Layer)
- 데이터 처리 전문으로 담당


Mybatis 장점
- 간결한 코드의 처리
- sql 문의 분리 운영
- spring과  연동으로 자동화된 처리
- 동적 sql을 이용한 제어 기능

SqlSessionFactory 객체 설정
 - 데이터 베이스와의 연결과 sql의 실행에 대한 모든 것을 가진 가장 중요한 객체
 

모델2 패턴 -> 화면과 데이터 처리를 분리해서 재사용이 가능하도록 하는 구조
- 개발자와 웹 퍼블리셔의 영역을 분리할 수 있다.
- 컨트롤러의 uri를 통해 뷰를 제어하기에 뷰 교체나 변경과 같은 유지보수에 유용
- front controller 패턴
  - 전체 로직의ㅏ 일부만 컨트롤러가 처리하도록 변경 -> 전체 로직의 일부를 컨트롤러에 위임하고 모든 흐름의 제어는 앞쪽 front controller가 담당
  
 -> 사용자의 모든 요청은 fornt controller에게 전달  -> 적절한 컨트롤러 찾아 호출
 -> 컨트롤런즌 적절한 서비스 객체를 찾아 호출하고 서비스는 데이터베이스의 작업을 담당하는 dao를 이용해 원하는 데이터를 요청
 -> dao는 mybatis를 이용하는 mapper를 통해 원하는 작업 수행, 
 -> 서비스가 처리한 데이터를 컨트롤러에게 전달하게 되면 컨트롤러는 다시 mvc쪽으로 데이터를 전달
 
 
 스프링 mvc 컨트롤러가 처리하는 것
 - 파라미터 수집  : 요청에 필요한 데이터를 추출하고 dto or vo 로 변환하는 파라미터의 수집작업
 - 애노테이션을 통한 간편 설정
 - 로직의 집중 
 - 테스트의 편리함 
 
 자주 사용하는 애노테이션 종류
 - @Controller : 컨트롤러 객체임을 명시
 - @ReqeustMapping : 특정 URI에 매칭되는 클래스나 메소드임을 명시 
 - @RequestParam : 요청에서 특정한 파라미터의 값을 찾아낼 때 사용
 - @RequestHeader : 요청에서 특정한 http헤더 정보를 추출할 때 사용
 - @PathVariable : 현재 uri에서 원하는 정보 추출 시 사용
 - @CookieValue : 현재 사용자의 쿠키가 존재하는 경우 쿠키의 이름을 이용해 쿠키의 값 추출
 - @ModelAttribute : 자동으로 해당 객체를 뷰까지 전달하도록 만드는 애노테이션
 - @SessionAttribute : 세션상에서 모델의 정보를 유지하고 싶은 경우 사용
 - @InitBinder : 파라미터를 수집해 객체로 만들 경우에 커스터 마이징
 - @ResponseBody : 리턴 타입이 http의 응답 메시지로 전송
 - @RequestBody : 요청 문자열이 그대로 파라미터로 전달 
 - @Repository : Dao 객체
 - @Service : 서비스 객체


비즈니스 계층의 구현
- 컨트롤러오 ㅏ같은 외부 호출이 영속 계층에 종속적인 상황을 막아줌
- 컨트롤러가 직접 영속 계층의 데이터베이스를 이용하면 트랜잭션 처리나 예외처리 등 모든 로직이 컨트롤러로 집중되고 비즈니스 계층은 컨트롤러로 하여금 처리해야하는 일을 분업하게 만들어준다.


컨트롤러의 모델 클래스
- 스프링 mvc 에서 제공ㄷ하는 데이터 전달용 객체
- map과 유사하게 키와 값으로 데이터를 저장하는 역할

컨트롤러에서 데이터 전달
- /board/register(GET) -> boardController -> register.jsp -> boardController -> success.jsp

- /board/register(post) -> boardController -> /board/listAll(GET) -> boardController
@ReqeustParam -> reqeust.getParameter()와 유사


// 예외 처리 방식
 - @ExceptionHandler 애노테이션 이용한 처리 
 - @ControllerAdvice를 이용한 처리
 - @ResponseStatus를 이요한 Http상태코드 처리
 
 페이징 처리 - 영속 계층, 비즈니스 계층
 - 상룡자에게 필요한 만큼 데이터를 전송해야 하고 서버에서 최대한 빠르게 결과를 만들어 내야한다는 것이 핵심
 - 1) 페이지 번호 등을 파라미터로 전달 ->: sql에 적절한 데이터를 뽑아 보여주기
   2) 목록 페이지 하단에 페이지 번호 보여주고 클릭 시 원하는 페이지로 이동
   
- 페이징 처린른 반드시 GET방식만 이용해야한다. (다른 사람에게 URL로 전달하는 경우가 많기에 반드시 GET으로 처리)
- 목록 페이지에서 특정 페이지에서 특정 게시물 보다가 다시 목록 가기 할 시 특정 페이지로 이동하는 기능 구현
- 반드시 필요한 페이지 번호만 제공하기

 화면 하단 페이징 처리
- 시작 페이지 번호 -> (endpage - 페이지 번호수 )+1  / 끝 페이지 번호 -> 현제페이지 번호 / 페이지 번호수 * 페이지 번호수  
- 전페 데이터 갯수

- 페이징 처리는 항상 get 방식을 이용해 작성 
- 이전 페이지 링크 / 이후 페이지 링크  


검색에 필요한 데이터
- 현재 페이지 번호 / 페이지당 보여지는 데이터 수 / 검색 종류 / 키워드

REST - uri은 하나의 고유한 리소스를 대표하도록 설계된 개념

- uri가 원하는 리소스르 ㄹ의미
- uri에는 식별할 수 있는 데이터를 같이 전달하는 것이 일반적

ajax의 특징
- 브라우저의 화면 전환이 없기에 사용자 경험 측면에서 좋음
- 서버에서 화면에 필요한 모든 데이터를 만드는 대신 서버는 필요한 데이터만 전달하기에 개발의 무게 중심이 브라우저 쪽으로 많이 배분된다.

-> rest 방식이 데이터를 호출하고 사용하는 방식을 의미한다면 ajax는 실제로 이용하는 수단이라고 본다.


AOP 관련 용어
- Aspect : 공통 관심사에 대한 추상적명칭
- Advice 실제로 기능을 구현한 객체
- Join points : 공통 관심사를 적용할 수 있는 대상, Spring aop에서는 각 객체의 메소드가 이에 해당
- Pointcuts : 여러 메서드 중 실제 advice가 적용될 대상 메소드
- target : 대상 메소드를 가진 객체
- Proxy : Advice가 적용되었을 때 만들어지는 객체
- Introduction : target에는 없는 새로운 메소드 나 인스턴스변수를 추가하는 기능
- Weaving : Advice와 target이 결합되어 프록시 객체를 만드는 과정

트랜잭션 기본 원칙
- 원자성
- 일관성
- 격리
- 영속성 
-> ACID 속성

@Transactional 우선수위
- 메서드 설정 > 클래스 설정 > 인터페이스 설정 
-> 클래스나 메서드에 필요한 애노테이션을 처리하는 것이 좋음

Filter와 인터셉터의 공통점과 차이점
- 특정 url에 접근할 때 제어하는 용도로 사용된다는 공통점 
- 필터는 동일 웹 애플리케이션의 영역 내에서 필요한 자원들을 활용, 스프링의 context를 접근하기가 어려움
- 인터셉터의 경우 스프링에서 관리되기 때문에 스프링 내 모든 객체에 접근이 가능하다, context내 존재하기에 context내의 모든 객체를 활용할 수 잇다.



